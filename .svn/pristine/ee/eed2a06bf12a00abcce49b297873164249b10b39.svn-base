module Main where

import Data.Char
import qualified Data.Text as T

main = do inp <- getContents
          putStr (outStr (tarefa3 (inStr inp)))


inStr :: String -> [String]
inStr [] = []
inStr ['\n'] = [[],[]]
inStr (x:xs) = case x of
    '\n' -> []:inStr xs
    otherwise -> case inStr xs of
        y:ys -> (x:y):ys
        [] -> [[x]]

outStr :: [String] -> String
outStr [] = "\n"
outStr t = unlines (map (T.unpack . T.stripEnd . T.pack) t)

tarefa3 :: [String] -> [String]
tarefa3 lines = [devolveFinal crdboneco car p1]
	where
		(p1, p2) = dividemapa lines
		(l1, l2) = devolveMovimento p2
		crdboneco = processacoordenada l1
		car = movimento l2


-- |Separa o tabuleiro das coordenadas
dividemapa :: [String] -> ([String], [String]) 
dividemapa [] = ([], [])
dividemapa l = splitAt (aux l) l
	where 
		aux :: [String] -> Int
		aux [] = 0
		aux (x:xs) = if(aux2 x) then 1 + aux xs else 0  
		
		aux2 :: String -> Bool
		aux2 [] = False
		aux2 (x:xs) = if(ord x == 35) then True else aux2 xs


-- |Separa a segunda parte do tabuleiro(coordenadas/movimento)
devolveMovimento :: [String] -> ([String], [String])
devolveMovimento l = splitAt (length l - 1) l



processacoordenada :: [String] -> (Int, Int)
processacoordenada (h:t) = (read x, read y) 
		where
			[x, y] = words h

-- |Devolve o caracter que define o movimento
movimento :: [String] -> Char
movimento (h:t) = if(length h >=1) then head h else ' '

moveBoneco :: (Int,Int) -> Char -> (Int, Int)
moveBoneco (l1, l2) c |c == 'U' = (l1 , l2 + 1)
				   	  |c == 'D' = (l1 , l2 - 1)
				      |c == 'L' = (l1 - 1  , l2)
				      |c == 'R' = (l1 + 1  , l2)
				      |otherwise = (l1, l2)

-- |Verifica se o movimento Ã© valido
movimentoValido :: [String] -> (Int, Int) -> Bool
movimentoValido l crd = percorreLinhas (reverse l) crd
	where
		percorreLinhas :: [String] -> (Int, Int) -> Bool
		percorreLinhas [] _ = False
		percorreLinhas (h:t) (p1, p2) = if(p2 == 0) then (percorreColunas h  p1) else (percorreLinhas t (p1, p2 - 1)) 

		percorreColunas :: String -> Int -> Bool
		percorreColunas [] _ = False
		percorreColunas (z:zs) n = if(n == 0) then if(z /= ' ') then False 
																else True 
											  else percorreColunas zs (n-1)

-- |Devolve as coordenadas do boneco depois do movimento
devolveFinal :: (Int, Int) -> Char -> [String] -> String
devolveFinal cb mv mp = if(movimentoValido mp wt) then xs ++ " " ++ ys else z ++ " " ++ zs
	where
		xs = show (fst (moveBoneco cb mv))
		ys = show (snd (moveBoneco cb mv))
		z = show (fst cb)
		zs = show (snd cb)
		wt = moveBoneco cb mv