module Main where

import qualified Data.Text as T
import Data.Char
--import Data.String.Utils

inStr :: String -> [String]
inStr [] = []
inStr ['\n'] = [[],[]]
inStr (x:xs) = case x of
    '\n' -> []:inStr xs
    otherwise -> case inStr xs of
        y:ys -> (x:y):ys
        [] -> [[x]]

teste:: String -> IO ()
teste file = do
	content <- readFile file
	putStr (outStr (simplificaMapa (colocaTudo (inStr content)))) 

outStr :: [String] -> String
outStr [] = "\n"
outStr t = unlines (map (T.unpack . T.stripEnd . T.pack) t)

{-main = do inp <- getContents
          putStr (outStr (tarefa2 (inStr inp)))

tarefa2 :: [String] -> [String]-}

dividemapa :: [String] -> ([String], [String]) --separa o tabuleiro das coordenadas
dividemapa [] = ([], [])
dividemapa l = splitAt (aux l) l
	where 
		aux :: [String] -> Int
		aux [] = 0
		aux (x:xs) = if(aux2 x) then 1 + aux xs else 0  
		
		aux2 :: String -> Bool
		aux2 [] = False
		aux2 (x:xs) = if(ord x == 35) then True else aux2 xs  

divideLinha :: String -> (String, String)
divideLinha l =	break (/= '#') l

substituiHastags :: String -> String
substituiHastags [x] = ['#']
substituiHastags (h:t) | h == '#' = ' ' : substituiHastags t

juntaLinha :: String -> String
juntaLinha l = (substituiHastags l1) ++ reverse(y) ++ (reverse (substituiHastags x))
	where
		(l1, l2) = divideLinha l
		(x, y) = divideLinha (reverse l2)


simplificaMapa :: [String] -> [String]
simplificaMapa [] = []
simplificaMapa (h:t) = juntaLinha h : simplificaMapa t 							

colocaBoneco :: [String] -> (Int,Int) -> [String]
colocaBoneco l (x,y) = reverse (percorreLinhas (reverse l) (x,y)) 
	where
		percorreLinhas :: [String] -> (Int, Int) -> [String]
		percorreLinhas (h:t) (p1, p2) = if(p2 == 0) then ((percorreColunas h  p1) : t) else (h : percorreLinhas t (p1, p2 - 1)) 

		percorreColunas :: String -> Int -> String
		percorreColunas [] _ = []
		percorreColunas (z:zs) n = if(n == 0) then 'o' : zs else (z : percorreColunas zs (n-1))

colocaCaixa :: [String] -> (Int,Int) -> [String]
colocaCaixa l (x,y) = reverse (percorreLinhas (reverse l) (x,y)) 
	where
		percorreLinhas :: [String] -> (Int, Int) -> [String]
		percorreLinhas (h:t) (p1, p2) = if(p2 == 0) then ((percorreColunas h  p1) : t) else (h : percorreLinhas t (p1, p2 - 1)) 

		percorreColunas :: String -> Int -> String
		percorreColunas [] _ = []
		percorreColunas (z:zs) n = if(n == 0) then 'H' : zs else (z : percorreColunas zs (n-1))


colocaCaixas :: [String] -> [(Int, Int)] -> [String]
colocaCaixas l [z] = colocaCaixa l z 
colocaCaixas l (h:t) = colocaCaixas (colocaCaixa l h) t 


colocaTudo :: [String] -> [String]
colocaTudo l = colocaBoneco (colocaCaixas l1 t) h
	where
		(l1, l2) = dividemapa l
		crd = processacoordenadas l2
		(h:t) = crd 

processacoordenadas :: [String] -> [(Int, Int)]
processacoordenadas [] = [] 
processacoordenadas (h:t) = (read x, read y) : processacoordenadas t
	where
		[x,y] = words h


