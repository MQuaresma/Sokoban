{-|
Module : Main
Descrição : Módulo de Haskell referente à quinta tarefa do projeto de LI.
Copyright : Miguel Quaresma <miguelquaresma97@gmail.com>
			João Nogueira
-}
module Main where

import qualified Data.Text as T
import Graphics.Gloss
import GlossExtras

main = do inp <- getContents
          let (x,y) = tarefa5 (readPicture inp)
          putStrLn (show (round x) ++ " " ++ show (round y))

teste :: Picture -> IO()
teste pic = let (x,y) = tarefa5 pic in putStrLn (show (round x) ++ " " ++ show (round y))


tarefa5 :: Picture -> (Float, Float)
tarefa5 pic = medidas pic


-- | Recebe o input e devolve as medidas do menor rectangulo que enquadra a picture
medidas :: Picture -> (Float, Float)
medidas Blank = (0.0,0.0)
medidas (Polygon (h:t)) = ((maxLarg (h:t) (fst h)) - (minLarg (h:t) (fst h)), (maxAlt (h:t) (snd h)) - (minAlt (h:t) (snd h)))
medidas (Line (h:t)) = ((maxLarg (h:t) (fst h)) - (minLarg (h:t) (fst h)), (maxAlt (h:t) (snd h)) - (minAlt (h:t) (snd h)))
medidas (Circle r) = (abs(2*r), abs(2*r))
medidas (Bitmap w h _ _) = (fromIntegral w, fromIntegral h)
medidas (Color _ pic) = medidas pic
medidas (Translate _ _ pic) = medidas pic
medidas (Rotate _ pic) = medidas pic
medidas (Scale x1 y1 pic) = let (x,y) = medidas pic in (x*x1, y*y1)
medidas (Pictures (h:t)) |noTransform (h:t) = maxTpl (medidas h) (medidas (Pictures t))
						 |otherwise = maxTpl (medidasPic h) (medidasPic (Pictures t))
medidas _ = (0.0,0.0)

 -- | Devolve o maior rectangulo envolvente  
maxTpl :: (Float, Float) -> (Float, Float) -> (Float, Float)
maxTpl p1 p2 |x >= x1 && y >= y1 = p1
			 |x >= x1 && y <= y1 = (x, y1)
			 |x <= x1 && y >= y1 = (x1, y)
			 |otherwise = p2
	where
		(x, y) = p1
		(x1, y1) = p2


medidasPic :: Picture -> (Float, Float)
medidasPic Blank = (0.0,0.0)
medidasPic (Polygon (h:t)) = ((maxLarg (h:t) (fst h)) - (minLarg (h:t) (fst h)), (maxAlt (h:t) (snd h)) - (minAlt (h:t) (snd h)))
medidasPic (Line (h:t)) = ((maxLarg (h:t) (fst h)) - (minLarg (h:t) (fst h)), (maxAlt (h:t) (snd h)) - (minAlt (h:t) (snd h)))
medidasPic (Circle r) = (abs(2*r), abs(2*r))
medidasPic (Bitmap w h _ _) = (fromIntegral w, fromIntegral h)
medidasPic (Color _ pic) = medidasPic pic
medidasPic (Translate x y pic) = let (z1, z2) = medidasPic pic in (abs (x) + abs(z1), abs(y) + abs(z2))
medidasPic (Rotate _ pic) = medidasPic pic
medidasPic (Scale x1 y1 pic) = let (x,y) = medidasPic pic in (x*x1, y*y1)
medidasPic (Pictures (h:t)) = maxTpl (medidasPic h) (medidasPic (Pictures t))
medidasPic _ = (0.0,0.0)




-- | Verifica se é aplicada alguma translação ao input
noTransform :: [Picture] -> Bool
noTransform [] = True
noTransform ((Translate _ _ _) : t) = False
noTransform ((Rotate _  _):t) = False
noTransform ((Pictures h): t) = noTransform h && noTransform t
noTransform (_:t) = noTransform t

-- | Devolve o ponto com a maior ordenada 
maxAlt :: [(Float, Float)] -> Float -> Float
maxAlt [] n = n
maxAlt ((x,y):t) n = if(y >= n) then maxAlt t y else maxAlt t n

-- | Devolve o ponto com a menor ordenada
minAlt :: [(Float, Float)] -> Float -> Float
minAlt [] n = n
minAlt ((x,y):t) n = if(y <= n) then minAlt t y else minAlt t n

-- | Devolve o ponto com a maior abcissa
maxLarg :: [(Float, Float)] -> Float -> Float
maxLarg [] n = n
maxLarg ((x,y):t) n = if(x >= n) then maxLarg t x else maxLarg t n

-- | Devolve o ponto com a menor abcissa
minLarg :: [(Float, Float)] -> Float -> Float
minLarg [] n = n
minLarg ((x,y):t) n = if(x <= n) then minLarg t x else minLarg t n
