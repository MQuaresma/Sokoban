{-|
Module : Main
Descrição : Módulo de Haskell referente à quinta tarefa do projeto de LI.
Copyright : Miguel Quaresma <miguelquaresma97@gmail.com>
			João Nogueira
-}
module Main where

import qualified Data.Text as T
import Graphics.Gloss
import GlossExtras

main = do inp <- getContents
          let (x,y) = tarefa5 (readPicture inp)
          putStrLn (show (round x) ++ " " ++ show (round y))

tarefa5 :: Picture -> (Float, Float)
tarefa5 pic = medidas pic


-- | Recebe o input e devolve as medidas do menor rectangulo que enquadra a picture
medidas :: Picture -> (Float, Float)
medidas Blank = (0.0,0.0)
medidas (Circle r) = (2*r, 2*r)
medidas (Polygon p) = ((maxLarg p 0)- (minLarg p 0), (maxAlt p 0) - (minAlt p 0))
medidas (Translate _ _ pic) = medidas pic
medidas (Rotate _ pic) = medidas pic
medidas (Scale x1 y1 pic) = let (x,y) = medidas pic in (x*x1, y*y1)
medidas (Pictures (h:t)) = maxTpl (medidas h) (medidas (Pictures t))

 -- | Devolve o maior rectangulo envolvente  
maxTpl :: (Float, Float) -> (Float, Float) -> (Float, Float)
maxTpl p1 p2 |x >= x1 && y >= y1 = p1
			 |x >= x1 && y <= y1 = (x, y1)
			 |x <= x1 && y >= y1 = (x1, y)
			 |otherwise = p2
	where
		(x, y) = p1
		(x1, y1) = p2


-- | Verifica se é aplicada alguma translação ao input
noTranslate :: [Picture] -> Bool
noTranslate [] = True
noTranslate ((Translate _ _ _) : t) = False
noTranslate (_:t) = noTranslate t

-- | Devolve o ponto com a maior ordenada 
maxAlt :: [(Float, Float)] -> Float -> Float
maxAlt [] n = n
maxAlt ((x,y):t) n = if(y >= n) then maxAlt t y else maxAlt t n

-- | Devolve o ponto com a menor ordenada
minAlt :: [(Float, Float)] -> Float -> Float
minAlt [] n = n
minAlt ((x,y):t) n = if(y <= n) then minAlt t y else minAlt t n

-- | Devolve o ponto com a maior abcissa
maxLarg :: [(Float, Float)] -> Float -> Float
maxLarg [] n = n
maxLarg ((x,y):t) n = if(x >= n) then maxLarg t x else maxLarg t n

-- | Devolve o ponto com a menor abcissa
minLarg :: [(Float, Float)] -> Float -> Float
minLarg [] n = n
minLarg ((x,y):t) n = if(x <= n) then minLarg t x else minLarg t n
