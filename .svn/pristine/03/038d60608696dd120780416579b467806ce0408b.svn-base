import Data.Char

leMapa :: String -> IO ()
leMapa file = do
	content <- readFile file
	let mapa = processMapa content
	putStr $ verificaMapa (fst mapa)

type Mapa = ([String], [(Int,Int)])

processMapa :: String -> Mapa
processMapa conteudo = (arrecadacao, coordenadas)
	where
		linhas = lines conteudo
		tamanhoArrecadacao = 11
		(arrecadacao, posicoes) = splitAt tamanhoArrecadacao linhas
		coordenadas = map processaPosicoes posicoes

processaPosicoes :: String -> (Int,Int)
processaPosicoes linha = (read x, read y)
	where
		[x,y] = words linha


verificaMapa :: [String] -> Int
verificaMapa [x] = if(lastCheck x) then 0 else length l
verificaMapa (h:t) = if(headCheck h) then |verificaInterior l1 = 0 
										  |otherwise = 
					 
					 else 1
	where
		l1 = take (length t - 1) t


verificaInterior :: String -> Bool --verifica se ha algum caracter do mapa que não seja "." , "#", " "
verificaInterior [] = True
verificaInterior (h:t) = if(aux1 h) then verificaInterior t else False 
	where 
		aux1 :: String -> Bool
		aux1 [] = True
		aux1 (x:xs) = if(ord x == 32 || ord x == 46 || ord x == 35) then aux1 xs else False


--
headCheck :: String -> Bool --verifica se todos os caracteres da primeira linha sao cardinais (#)
headCheck [] = True
headCheck (x:xs) = if(ord x == 35) then headCheck xs else False

lastCheck :: String -> Bool
lastCheck [] = True
lastCheck (h:t) = if(ord h == 35) then lastCheck t else False


verificarLados :: String -> Bool --verifica se os contornos laterais são 
verificarLados (h:t) = if(ord h == 35 && ord (last t) == 35) then True else False


testacomprimento :: [String] -> Bool
testacomprimento [x] = True
testacomprimento (x:xs) |length x == length (head xs) = testacomprimento xs
						|otherwise = False
