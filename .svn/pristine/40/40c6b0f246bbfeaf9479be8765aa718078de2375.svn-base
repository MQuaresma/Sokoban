{-|Module : Main
Descrição : Módulo de Haskell referente à última tarefa do projeto de LI.
Copyright : Miguel Quaresma <miguelquaresma97@gmail.com>
			João Nogueira

Módulo final que tem por objetivo implementar um jogo semelhante ao Sokoban  

-}

module Main where

import System.Directory
import Data.Char
import Graphics.Gloss 
import Graphics.Gloss.Data.Picture 
import Graphics.Gloss.Interface.Pure.Game 


type Coordenadas = (Float, Float)

-- | Estado do jogo:
--
-- * Dimensões do mapa
-- * Coordenadas da boneco no mapa
-- * Coordenadas das caixas
-- * Imagem da boneco
-- * Imagem da caixa
type Mapa = ((Float,Float),Coordenadas,[Coordenadas], [Coordenadas], Picture, Picture, Picture)



main :: IO ()
main = do   boneco <- loadBMP "/home/miguel/Imagens/Sokoban/boneco.bmp" -- carrega a imagem da boneco
            caixa <- loadBMP "/home/miguel/Imagens/Sokoban/crate.bmp" -- carega a imagem das caixas
            ficheiroMapa <- readFile "/home/miguel/Documentos/Disciplinas/Laboratórios_de_Informática/MapasSokoban/mapa1.txt"
            parede <- loadBMP "/home/miguel/Imagens/Sokoban/paredeF.bmp"
            gameManager boneco caixa parede ficheiroMapa


-- | Função encarregue de iniciar o jogo
gameManager :: Picture -> Picture -> Picture -> String -> IO()
gameManager boneco caixa parede mapaF = joga ((400,400),((fromIntegral (x1+1)) *20, (fromIntegral (x2+1)) *20), coordsCaixas , coordsParedes ,boneco, caixa, parede) desenhaMapa reageEvento
    where 
        (tabuleiro, coords) = dividemapa (inStr mapaF)
        ((x1, x2):t) = processacoordenadas (removeInv coords)
        tabuleiroSimples = reverse (tarefa2 (inStr mapaF))
        coordsParedes = map (*20) (converte (recolheParedes tabuleiroSimples 1))
        coordsCaixas = map (*20) (converte (recolheCaixas tabuleiroSimples 1))
        converte :: [(Int, Int)] -> [(Float, Float)]
        converte [] = []
        converte ((x,y):t) = (fromIntegral x, fromIntegral y) : converte t


-- | Move a boneco uma coordenada para o lado
moveBoneco :: (Float,Float) -> Mapa -> Mapa
moveBoneco (x,y) ((xMapa,yMapa),(xBoneco,yBoneco),coordsCaixas, coordsParedes, boneco, caixa, paredes) = ((xMapa,yMapa),(arredonda xMapa (x + xBoneco),arredonda yMapa (y + yBoneco)),coordsCaixas, coordsParedes, boneco, caixa, paredes)
    where
    -- Evita que a  boneco saia fora do mapa
    -- assume que a boneco é um quadrado com arestas de comprimento 20
    arredonda limite p = max 20 (min p (limite-20))

-- | Move a caixa caso o boneco a empurre
-- | Move a boneco uma coordenada para o lado
{-moveCaixa :: (Float,Float) -> Mapa -> Mapa
moveCaixa (x,y) ((xMapa,yMapa),(xBoneco,yBoneco),(xCaixa, yCaixa), boneco, caixa) = ((xMapa,yMapa),(xBoneco, yBoneco),(arredonda xMapa (x + xCaixa),arredonda yMapa (y + yCaixa)) ,boneco, caixa)
    where
    -- Evita que a  boneco saia fora do mapa
    -- assume que a boneco é um quadrado com arestas de comprimento 20
    arredonda limite p = max 20 (min p (limite-20))-}


-- | Desenha o jogo dentro da janela
desenhaMapa :: Mapa -> Picture
desenhaMapa ((xMapa,yMapa),(x,y), coordsCaixas, coordsParedes, boneco, caixa, paredes) = Pictures [borda,tabuleiro,figura, Pictures(colocaCaixas coordsCaixas caixa), Pictures (colocaParedes coordsParedes paredes)]
    where
    -- borda do mapa a preto, centrada na janela
    borda = Translate (-(xMapa+20)/2) (-(yMapa+20)/2) $ Color black (Polygon [(0,0),(0,yMapa + 20),(xMapa + 20,yMapa + 20),(xMapa + 20,0)])
    -- mapa a branco, centrado na janela
    tabuleiro = Translate (-xMapa/2) (-yMapa/2) $ Color white (Polygon [(0,0),(0,yMapa),(xMapa,yMapa),(xMapa,0)])
    -- boneco dentro do mapa do jogo
    figura = Translate (-xMapa/2) (-yMapa/2) $ Translate x y boneco
    --coloca a caixa no local correto
    colocaCaixas :: [(Float, Float)] -> Picture -> [Picture]
    colocaCaixas [] _ = []
    colocaCaixas (h:t) caixa = (objeto h  caixa) : colocaCaixas t caixa
    objeto :: (Float, Float) -> Picture -> Picture
    objeto (x1,y1) caixa =  Translate (-xMapa/2) (-yMapa/2) $ Translate x1 y1 caixa
    --coloca as paredes
    colocaParedes :: [(Float, Float)] -> Picture -> [Picture]
    colocaParedes [] _ = []
    colocaParedes (h:t) parede = (objetoS h  parede) : colocaParedes t parede
    objetoS :: (Float, Float) -> Picture -> Picture
    objetoS (x1,y1) parede =  Translate (-xMapa/2) (-yMapa/2) $ Translate x1 y1 parede


move :: (Float,Float) -> Char -> (Float, Float)
move (l1, l2) c |c == 'U' = (l1 , l2 + 20)
				|c == 'D' = (l1 , l2 - 20)
				|c == 'L' = (l1 - 20  , l2)
				|c == 'R' = (l1 + 20  , l2)

-- | Reage ao pressionar das setas do teclado, movendo a bola 5 pixéis numa direção
reageEvento :: Event -> Mapa -> Mapa
reageEvento (EventKey (SpecialKey KeyUp)    Down _ _) mapa  |testa = if(elem movimento coordsCaixas) then moveBoneco (0,20) mapaNovo else  moveBoneco (0,20)  mapa  
                                                            |otherwise = mapa
    where
        (limitesMp, posB, coordsCaixas, coordsParedes, boneco, caixa, parede) = mapa
        movimento = move posB 'U'
        testa = movimentoValido 'U' posB coordsCaixas coordsParedes
        coordsNovas = devolveNovo movimento 'U' coordsCaixas
        mapaNovo = (limitesMp, posB, coordsNovas, coordsParedes, boneco, caixa, parede)

reageEvento (EventKey (SpecialKey KeyDown)  Down _ _) mapa  |testa = if(elem movimento coordsCaixas) then moveBoneco (0,-20) mapaNovo else  moveBoneco (0,-20)  mapa  
                                                            |otherwise = mapa
    where
        (limitesMp, posB, coordsCaixas, coordsParedes, boneco, caixa, parede) = mapa
        movimento = move posB 'D'
        testa = movimentoValido 'D' posB coordsCaixas coordsParedes
        coordsNovas = devolveNovo movimento 'D' coordsCaixas
        mapaNovo = (limitesMp, posB, coordsNovas, coordsParedes, boneco, caixa, parede)

reageEvento (EventKey (SpecialKey KeyLeft)  Down _ _) mapa  |testa = if(elem movimento coordsCaixas) then moveBoneco (-20, 0) mapaNovo else  moveBoneco (-20, 0)  mapa  
                                                            |otherwise = mapa
    where
        (limitesMp, posB, coordsCaixas, coordsParedes, boneco, caixa, parede) = mapa
        movimento = move posB 'L'
        testa = movimentoValido 'L' posB coordsCaixas coordsParedes
        coordsNovas = devolveNovo movimento 'L' coordsCaixas
        mapaNovo = (limitesMp, posB, coordsNovas, coordsParedes, boneco, caixa, parede)

reageEvento (EventKey (SpecialKey KeyRight) Down _ _) mapa  |testa = if(elem movimento coordsCaixas) then moveBoneco (20, 0) mapaNovo else  moveBoneco (20, 0)  mapa  
                                                            |otherwise = mapa
    where
        (limitesMp, posB, coordsCaixas, coordsParedes, boneco, caixa, parede) = mapa
        movimento = move posB 'R'
        testa = movimentoValido 'R' posB coordsCaixas coordsParedes
        coordsNovas = devolveNovo movimento 'R' coordsCaixas
        mapaNovo = (limitesMp, posB, coordsNovas, coordsParedes, boneco, caixa, parede)

reageEvento _ mapa = mapa -- ignora qualquer outro evento


-- | Verifica se o boneco se pode mover na direção desejada
movimentoValido :: Char -> (Float, Float) -> [Coordenadas] -> [Coordenadas] -> Bool
movimentoValido c coordsBoneco coordsCaixas coordsParedes | elem (nextMove) coordsParedes = False
                                                          | elem (nextMove) coordsCaixas && elem (move nextMove c) coordsCaixas = False 
                                                          | elem (nextMove) coordsCaixas && elem (move nextMove c) coordsParedes = False
                                                          | elem (nextMove) coordsCaixas = True
                                                          |otherwise = True
    where
        nextMove = move coordsBoneco c

-- | Não reage ao passar do tempo.
reageTempo :: Float -> mundo -> mundo
reageTempo t m = m

-- | Função que cria um jogo.
joga :: mundo -> (mundo -> Picture) -> (Event -> mundo -> mundo) -> IO ()
joga mapaInicial desenha reage = play
    (InWindow "Sokoban" (1920, 1080) (0, 0)) -- Tamanho da janela do jogo
    (black) -- Côr do fundo da janela
    45 -- refresh rate
    mapaInicial -- mapa inicial
    desenha -- função que desenha o mapa
    reage -- função que reage a um evento (carregar numa tecla, mover o rato, etc)
    reageTempo -- função que reage ao passar do tempo 



-- | Recolhe as posições dos cardinais/paredes do mapa
recolheParedes :: [String] -> Int -> [(Int, Int)]
recolheParedes [] _ = []
recolheParedes (h:t) n = recolheLinha h n 1 ++ recolheParedes t (n+1)
    where
        recolheLinha :: String -> Int -> Int -> [(Int, Int)]
        recolheLinha [] _ _  = []
        recolheLinha (h:t) linha col | h == '#' = (col, linha) : recolheLinha t linha (col + 1)
                                     |otherwise = recolheLinha t linha (col + 1)



-- | Recolhe as posições das caixas do mapa
recolheCaixas :: [String] -> Int -> [(Int, Int)]
recolheCaixas [] _ = []
recolheCaixas (h:t) n = recolheLinha h n 1 ++ recolheCaixas t (n+1)
    where
        recolheLinha :: String -> Int -> Int -> [(Int, Int)]
        recolheLinha [] _ _  = []
        recolheLinha (h:t) linha col | h == 'H' = (col, linha) : recolheLinha t linha (col + 1)
                                     |otherwise = recolheLinha t linha (col + 1)

-- | 
devolveNovo :: Coordenadas -> Char -> [Coordenadas] -> [Coordenadas]
devolveNovo cords c (x:xs) |cords == x = (novaCoord : xs)
                           |otherwise = x : (devolveNovo cords c xs)
    where
        novaCoord = move cords c 


-- | Funções da Tarefa 2
tarefa2 :: [String] -> [String]
tarefa2 linhas = colocaTudo (reverse (simplificaMapa (reverse tab) todas (reverse tab))) coordenadasF 
    where
        (tab, coordenadas) = dividemapa linhas
        coordenadasF = processacoordenadas (removeInv coordenadas) 
        todas = recolheCords 0 0 tab

-- | Remove os cardinais redundantes do mapa inteiro
simplificaMapa :: [String] -> [(Int, Int)] -> [String] -> [String]
simplificaMapa [] _ _ = []
simplificaMapa (h:t) cds tab = removeDeLinha h cds tab : simplificaMapa t (drop (length h) cds) tab


-- | Remove os cardinais redundates de cada linha, verificando, caso o caracter em questão seja um cardinal, todos os caracteres à sua volta e atuando em conformidade
removeDeLinha :: String-> [(Int, Int)]-> [String] -> String
removeDeLinha [] _ _ = []
removeDeLinha (h:t) (x:xs) tab |devolveCarater x tab == ' ' = ' ' : removeDeLinha t xs tab
                               |devolveCarater x tab == '.' = '.' : removeDeLinha t xs tab
                               |(devolveCarater (l1, l2 + 1) tab == ' ' || devolveCarater (l1 + 1, l2) tab == ' ' || devolveCarater (l1, l2 - 1) tab == ' ' || devolveCarater (l1 - 1, l2) tab == ' ' || devolveCarater (l1 + 1, l2 + 1) tab == ' ' || devolveCarater (l1 - 1, l2 - 1) tab == ' ' || devolveCarater (l1 - 1, l2 + 1) tab == ' ' || devolveCarater (l1 + 1, l2 - 1) tab == ' ') = '#' :  removeDeLinha t xs tab
                               |(devolveCarater (l1, l2 + 1) tab == '.' || devolveCarater (l1 + 1, l2) tab == '.' || devolveCarater (l1, l2 - 1) tab == '.' || devolveCarater (l1 - 1, l2) tab == '.' || devolveCarater (l1 + 1, l2 + 1) tab == '.' || devolveCarater (l1 - 1, l2 - 1) tab == '.' || devolveCarater (l1 - 1, l2 + 1) tab == '.' || devolveCarater (l1 + 1, l2 - 1) tab == '.') = '#' :  removeDeLinha t xs tab
                               |(devolveCarater (l1, l2 + 1) tab == '#' && devolveCarater (l1 + 1, l2) tab == '#' && devolveCarater (l1, l2 - 1) tab == '#' && devolveCarater (l1 - 1, l2) tab == '#' && devolveCarater (l1 + 1, l2 + 1) tab == '#' && devolveCarater (l1 - 1, l2 - 1) tab == '#' && devolveCarater (l1 - 1, l2 + 1) tab == '#' && devolveCarater (l1 + 1, l2 - 1) tab == '#') = ' ' :  removeDeLinha t xs tab
    where
        (l1, l2) = x


-- | Devolve o carater correspondente a um par de coordenadas
devolveCarater :: (Int, Int) -> [String] -> Char
devolveCarater crd mp = percorreLinhas mp crd 0
    where
        percorreLinhas :: [String] -> (Int,Int) -> Int -> Char
        percorreLinhas [] _ n = '#'
        percorreLinhas (h:t) (p1, p2) n |p2 == n = percorreColunas h p1 0
                                        |otherwise = percorreLinhas t (p1, p2) (n+1)
        
        percorreColunas :: String -> Int -> Int -> Char
        percorreColunas [] _ n = '#'
        percorreColunas (x:xs) p1 n |p1 == n = x 
                                    |otherwise = percorreColunas xs p1 (n+1)


-- | Recolhe todas as coordenadas referentes a todas posições possíveis no mapa para facilitar a remoção dos cardinais                    
recolheCords :: Int -> Int -> [String] -> [(Int, Int)]
recolheCords _ _ [] = []
recolheCords c l (x:xs) = (aux c l x) ++ recolheCords c (l+1) xs
    where
        aux :: Int -> Int -> String -> [(Int, Int)]
        aux c l  [] = []
        aux c l (h:t) = (c, l) : aux (c+1) l t

-- | Coloca o boneco e as caixas no mapa
colocaTudo :: [String] -> [(Int, Int)] -> [String]
colocaTudo l (h:t) = colocaBoneco (colocaCaixas l t) h


-- | Coloca o boneco no mapa
colocaBoneco :: [String] -> (Int,Int) -> [String]
colocaBoneco l (x,y) = reverse (percorreLinhas (reverse l) (x,y)) 
    where
        percorreLinhas :: [String] -> (Int, Int) -> [String]
        percorreLinhas (h:t) (p1, p2) |p2 == 0 = (percorreColunas h  p1) : t 
                                      |otherwise = h : percorreLinhas t (p1, p2 - 1) 

        percorreColunas :: String -> Int -> String
        percorreColunas [] _ = []
        percorreColunas (z:zs) n |n == 0 = 'o' : zs 
                                 |otherwise = z : percorreColunas zs (n-1)


-- | Chama a função __colocaCaixa__ para colocar todas as caixas no mapa
colocaCaixas :: [String] -> [(Int, Int)] -> [String]
colocaCaixas l [z] = colocaCaixa l z 
colocaCaixas l (h:t) = colocaCaixas (colocaCaixa l h) t 


-- | Coloca uma caixa no mapa
colocaCaixa :: [String] -> (Int,Int) -> [String]
colocaCaixa l (x,y) = reverse (percorreLinhas (reverse l) (x,y)) 
    where
        percorreLinhas :: [String] -> (Int, Int) -> [String]
        percorreLinhas (h:t) (p1, p2) | p2 == 0 = (percorreColunas h  p1) : t 
                                      |otherwise = h : percorreLinhas t (p1, p2 - 1) 

        percorreColunas :: String -> Int -> String
        percorreColunas [] _ = []
        percorreColunas (z:zs) n |n == 0 = if(z == '.') then 'I' : zs else 'H' : zs 
                                 |otherwise = z : percorreColunas zs (n-1)


-- | Funções Gerais


-- | Divide o ficheiro em duas partes a primeira contendo o mapa e a segunda as coordenadas
dividemapa :: [String] -> ([String], [String]) 
dividemapa [] = ([], [])
dividemapa l = splitAt (aux l) l
    where 
        aux :: [String] -> Int
        aux [] = 0
        aux (x:xs) = if(aux2 x) then 1 + aux xs else 0  
        
        aux2 :: String -> Bool
        aux2 [] = False
        aux2 (x:xs) = if(ord x == 35) then True else aux2 xs  


-- | Converte a lista de coordenadas, ainda em lista de /strings/, numa lista de pares de /Int/s 
processacoordenadas :: [String] -> [(Int, Int)]
processacoordenadas [] = []
processacoordenadas (h:t) = (read x, read y) : processacoordenadas t 
        where
            [x, y] = words h


-- |Remove a coordenadas inválidas (com um so nro; com caracteres que não são nros ou linhas vazias)
removeInv :: [String] -> [String]
removeInv [] = []
removeInv (x:xs) | x==""= removeInv xs
                 | length (words x) /= 2 = removeInv xs
                 | remaux x == False = removeInv xs
                 | otherwise = x : removeInv xs

remaux :: String -> Bool
remaux [] = True
remaux (h:t) = if isDigit h || h == ' ' then remaux t else False

inStr :: String -> [String]
inStr [] = []
inStr ['\n'] = [[],[]]
inStr (x:xs) = case x of
    '\n' -> []:inStr xs
    otherwise -> case inStr xs of
        y:ys -> (x:y):ys
        [] -> [[x]]